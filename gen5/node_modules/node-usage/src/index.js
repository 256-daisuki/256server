import { tableParse } from './utils';
import { spawn } from 'child_process';

class UsageMonitor {
  constructor(opt = {}) {
    this.interval = opt.interval || 3000;
  }

  run(pid, opts = {}, cb) {
    if (!pid) {
      throw new Error('no pid given');
    }

    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }

    let output = '';
    const p = this.createPSProcess();
    p.stdout.on('data', (data) => {
      output += data.toString();
    });

    p.on('exit', () => {
      this.formatPsOutput(output);
      const { error, data } = this.parse(pid, opts);
      cb(error, data);

      if (!error) {
        setTimeout(() => {
          this.run(pid, opts, cb);
        }, this.interval);
      }

    });
  }

  createPSProcess() {
    // platform may be ['darwin', 'freebsd', 'linux', 'sunos' or 'win32']
    const platform = process.platform;
    let args = [];
    switch (platform) {
      case 'darwin': {
        args = ['ax', '-o', 'pgid,pid,vsz,rss,%mem,%cpu,stat,time,start', '-c'];
        break;
      }
      case 'win32': {
        throw new Error(`${platform} not supported yet`);
      }

      // for *nux, tested on ubuntu linux only
      default:
        args = ['ax', 'o', 'pgid,pid,vsz,rss,%mem,%cpu,stat,time,start'];
    }

    return spawn('ps', args);
  }

  formatPsOutput(output) {
    this.rows = tableParse(output);
  }

  parse(pid, opts) {
    const countChild = opts.countChild === false ? false : true;
    let error;
    let data;
    if (!countChild) {
      try {
        data = this.usageOfProcess(pid);
      } catch (e) {
        error = e;
      }
    } else {
      try {
        const pgid = this.processGroupNumber(pid);
        data = this.usageOfProcessGroup(pgid);
      } catch (e) {
        error = e;
      }
    }

    return { error, data };
  }


  processGroupNumber(pid) {
    const pRows = this.rows.filter(r => r.PID === String(pid));
    if (pRows.length !== 1) {
      throw new Error(`no such process with pid ${pid}`);
    }

    return pRows[0].PGID;
  }

  usageOfProcess(pid) {
    const pRows = this.rows.filter(r => r.PID === pid);
    if (pRows.length !== 1) {
      throw new Error(`no such process with pid ${pid}`);
    }

    return {
      MEM: pRows[0]['MEM'],
      RSS: pRows[0]['RSS'],
      VSZ: pRows[0]['VSZ'],
      '%MEM': pRows[0]['%MEM'],
      '%CPU': pRows[0]['%CPU'],
    };
  }

  usageOfProcessGroup(pgid) {
    const gRows = this.rows.filter((r) => r.PGID === pgid);

    if (gRows.length < 1) {
      throw new Error(`no such process with pid ${pid}`);
    }

    let mem = 0;
    let rss = 0;
    let vsz = 0;
    let memRate = 0;
    let cpuRate = 0;
    gRows.forEach((r) => {
      const memVal = parseInt(r.MEM, 10);
      mem += isNaN(memVal) ? 0 : memVal;

      const rssVal = parseInt(r.RSS, 10);
      rss += isNaN(rssVal) ? 0 : rssVal;

      const vszVal = parseInt(r.VSZ, 10);
      vsz += isNaN(vszVal) ? 0 : vszVal;

      const memRateVal = parseFloat(r['%MEM']);
      memRate += isNaN(memRateVal) ? 0 : memRateVal;

      const cpuRateVal = parseFloat(r['%CPU']);
      cpuRate += isNaN(cpuRateVal) ? 0 : cpuRateVal;
    });

    return {
      MEM: mem,
      RSS: rss,
      VSZ: vsz,
      '%MEM': memRate,
      '%CPU': cpuRate,
    };
  }
}

export default UsageMonitor;
