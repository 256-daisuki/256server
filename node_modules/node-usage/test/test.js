import { expect } from 'chai';
import { tableParse } from '../lib/utils';
import { EOL } from 'os';
import { spawn } from 'child_process';
import UsageMonitor from '../lib';

function delay(ms) {
  return new Promise((resole) => {
    setTimeout(() => {
      resole(true);
    }, ms);
  });
}

describe('tableParse', () => {
  it('parse', () => {
    const str = `name age${EOL}minge 12`;

    const res = tableParse(str);
    expect(res[0]).to.eql({ name: 'minge', age: '12' });
  });
});

describe('UsageMonitor', () => {
  const memMonitor = new UsageMonitor({ interval: 500 });

  let p = null;
  before(() => {
    p = spawn('sleep', ['20'], { detached: true });
    expect(p.pid).to.not.equal(null);
  });

  after(() => {
    if (p.pid) process.kill(-p.pid, 'SIGKILL');
  });

  it('should error when no process with pid', async () => {
    const fakePid = 10000000000;
    let error = null
    let checkTimes = 0;
    memMonitor.run(fakePid, (err, data) => {
      error = err;
      checkTimes += 1;
    });
    await delay(1500);

    const expectedError = new Error('no such process with pid 10000000000');
    expect(error).to.eql(expectedError);
    expect(checkTimes).to.equal(1);
  });

  it('should get usage for valid pid', async () => {
    let checkTimes = 0;
    let error = null;
    const results = [];
    memMonitor.run(p.pid, (err, data) => {
      if (err) error = err;
      if (data) results.push(data);

      checkTimes += 1;
    });

    await delay(1000);
    expect(error).to.equal(null);
    expect(checkTimes).to.equal(2);
    expect(results.length).to.equal(2);

    results.forEach((r) => {
      expect(parseInt(r.RSS, 10)).to.be.above(0);
    });

    const killed = process.kill(p.pid);
    expect(killed).to.equal(true);
    p.pid = null;
    await delay(800);

    expect(checkTimes).to.equal(3);
    expect(results.length).to.equal(2);
    const expectedError =  new Error(`no such process with pid ${p.pid}`);
    expect(error).to.eql(expectedError);
  });
});
